
###       This file was generated by the bin/pygen.py script using         ###
###       include/ES_C_API_Def_clean.h as input.                           ###
#')
# The variables and classes defined in this module handle
# serialization and deserialization of TCP packets consumed and
# emitted by Leica AT4xx laser trackers.

import io
import logging
from PIL import Image
import socket
import struct
import time
import threading

logging.basicConfig()
logger = logging.getLogger(__name__)
logger.setLevel(logging.DEBUG)

class OverviewVideoCameraParametersT(object):
  def __init__(self):
    self.__packet_size = 40
    self.__formats = [('<i i d d d i i ')]
    self.__sizes = [40]
    self.lBrightness = int(0)
    self.lContrast = int(0)
    self.dFocalLength = float(0)
    self.dHorizontalChipSize = float(0)
    self.dVerticalChipSize = float(0)
    self.bMirrorImageHz = int(0)
    self.bMirrorImageVt = int(0)

  def size(self):
     return self.__packet_size

  def unpack(self, packet):
    packet_elements = struct.Struct(self.__formats[0]).unpack(packet[:self.__sizes[0]])
    self.lBrightness = packet_elements[0]
    self.lContrast = packet_elements[1]
    self.dFocalLength = packet_elements[2]
    self.dHorizontalChipSize = packet_elements[3]
    self.dVerticalChipSize = packet_elements[4]
    self.bMirrorImageHz = packet_elements[5]
    self.bMirrorImageVt = packet_elements[6]
    return packet[self.__sizes[0]:]

  def pack(self):
    packet = b''
    packet_elements = ()
    packet_elements += (self.lBrightness,)
    packet_elements += (self.lContrast,)
    packet_elements += (self.dFocalLength,)
    packet_elements += (self.dHorizontalChipSize,)
    packet_elements += (self.dVerticalChipSize,)
    packet_elements += (self.bMirrorImageHz,)
    packet_elements += (self.bMirrorImageVt,)
    packet += struct.Struct(self.__formats[0]).pack(*packet_elements)
    return packet

class Connection(object):
    def __init__(self):
        self.__sock = None
        self.__stream = None
        self.__video_server_host = None
        self.__video_server_port = 5001
    
    def __del__(self):
        logger.debug("Destructing!")
        self.disconnect()

    def connect(self, host='192.168.0.1'):
        self.__video_server_host = host
        if self.__sock != None:
            raise Exception("Repeat connection. Only one connection to the laser tracker is allowed at one time.")

        try:
            # Create a UDP socket
            self.__sock = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
            self.__sock.settimeout(1)

            self.__stream = VideoStream(self.__sock, self.__video_server_host)
            self.__stream.start()
        except socket.timeout as ste:
            self.disconnect()
            logger.debug('Client timed out waiting for a connection to the laser tracker.')
            raise ste
    
        return self.__stream

    def disconnect(self):
        logger.debug("Disconnecting!")
        if self.__stream != None:
            self.__stream.stop()
            self.__stream.join()
        if self.__sock != None:
            self.__sock.close()
            self.__sock = None

class VideoStream(threading.Thread):
    def __init__(self, sock, host):
        super().__init__()
        self.__sock = sock
        self.__video_server_host = host
        self.__video_server_port = 5001
        self.__running = True
        self.__jpeg_signature = b'emScon>>'
        self.__image_buffer_size = 65536
        self.__bmp_chunk_size = 38400 # Fixed size for half a BMP images
        self.__bmp_frame_size = 78600 # Buffer to hold 2-BMP-chunk image
        self.__lock = threading.Lock()
        self.__frame_rate = int(0)
        self.__camera_parameters = OverviewVideoCameraParametersT()
        self.__image_data = None

    def __write(self, data):
        logger.debug('Sending data: {}'.format(data))
        if not self.__sock._closed:
            self.__sock.sendto(data, (self.__video_server_host, self.__video_server_port))
            logger.debug('VideoStream sent a {} byte packet.'.format(len(data)))

    def run(self):
        self.__write(b'LiveImageStart')
        bmp_chunk_index = 0
        bmp_chunk = None
        read_data = []
        while self.__running:
            try:
                logger.debug('Receiving video data...')
                read_data,server_address = self.__sock.recvfrom(self.__image_buffer_size)

                logger.debug('Acquiring lock (run)')
                self.__lock.acquire()
                logger.debug('Acquired lock (run)')
                if len(read_data) == 4:
                    # Frame rate
                    self.__frame_rate = struct.Struct('<i').unpack(read_data)
                    logger.debug('*** Received frame rate: {} ***'.format(self.__frame_rate))
                elif len(read_data) == self.__camera_parameters.size():
                    logger.debug('*** Received camera parameters. ***')
                    self.__camera_parameters.unpack(read_data)
                elif len(read_data) == self.__bmp_chunk_size:
                    if bmp_chunk_index == 0:
                        # BMP chunk 0
                        logger.debug('*** Received 1st BMP chunk. ***')
                        bmp_chunk = read_data
                        bmp_chunk_index = 1
                    else:
                        # BMP chunk 1
                        logger.debug('*** Received 2nd BMP chunk. ***')
                        self.__image_data = b''.join((bmp_chunk, read_data))
                        bmp_chunk_index = 0
                elif len(read_data) > len(self.__jpeg_signature) and read_data[:len(self.__jpeg_signature)] == self.__jpeg_signature:
                    logger.debug('*** Received JPEG image. ***')
                    self.__image_data = read_data[len(self.__jpeg_signature):]
                elif len(read_data) == 0:
                    logger.debug('*** No image data received. ***')
                    time.sleep(0.2)
                else:
                    logger.debug('*** Invalid video data: ***\n{}'.format(read_data))
                    logger.debug('Releasing lock (run exception)')
                    self.__lock.release()
                    logger.debug('Released lock (run exception)')
                    raise Exception('recieved invalid {}-byte video data'.format(len(read_data)))
                logger.debug('Releasing lock (run)')
                self.__lock.release()
                logger.debug('Released lock (run)')
            except socket.timeout as ste:
                logger.debug('VideoStream timed out waiting for laser tracker data.')
                logger.debug('Read data size: {}'.format(len(read_data)))
            except ConnectionAbortedError as cae:
                logger.debug('VideoStream socket connection was aborted: {}'.format(cae))
                self.__running = False
            except ConnectionResetError as cre:
                logger.debug('VideoStream socket connection was reset: {}'.format(cre))
                self.__running = False
        logger.debug('VideoStream is terminating...')

    def stop(self):
        self.__write(b'LiveImageStop')
        self.__running = False
    
    def next(self):
        logger.debug('Acquiring lock (next)')
        self.__lock.acquire()
        logger.debug('Acquired lock (next)')
        image_data = self.__image_data
        logger.debug('Releasing lock (next)')
        self.__lock.release()
        logger.debug('Released lock (next)')
        if image_data == None:
            return None
        image_buffer = io.BytesIO(image_data)
        return Image.open(image_buffer)

    def increase_frame_rate(self):
        self.__write(b'FrameRateStepUp')

    def decrease_frame_rate(self):
        self.__write(b'FrameRateStepDown')

    def set_frame_rate(self, frame_rate):
        self.__write(b''.join((b'SetFrameRate:', bytes(int(frame_rate)))))


    def get_frame_rate(self):
        self.__frame_rate = int(0)
        self.__write(b'GetFrameRate')
        frame_rate = int(0)
        while self.__running and frame_rate == 0:
            logger.debug('Acquiring lock (get_frame_rate)')
            self.__lock.acquire()
            logger.debug('Acquired lock (get_frame_rate)')
            frame_rate = self.__frame_rate
            logger.debug('Releasing lock (get_frame_rate)')
            self.__lock.release()
            logger.debug('Released lock (get_frame_rate)')
            time.sleep(0.2)
        return frame_rate

    def get_camera_parameters(self):
        self.__camera_parameters = None
        self.__write(b'RequestCameraParameters')
        camera_parameters = None
        while self.__running and camera_parameters == None:
            logger.debug('Acquiring lock (get_camera_parameters)')
            self.__lock.acquire()
            logger.debug('Acquired lock (get_camera_parameters)')
            camera_parameters = self.__camera_parameters
            logger.debug('Releasing lock (get_camera_parameters)')
            self.__lock.release()
            logger.debug('Released lock (get_camera_parameters)')
            time.sleep(0.2)
